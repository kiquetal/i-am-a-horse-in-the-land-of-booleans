(use 'i-am-a-horese-in-the-land-of-booleans')
(use 'i-am-a-horese-in-the-land-of-booleans)
(use 'i-am-a-horse-in-the-land-of-booleans)
ls
exit
(defn bol [x] (if (x? false) (false) (true)))
(defn bol [x] (if (x false) (false) (true)))
(bol false)
(bol (false))
(defn algo [x](str x "ssa"))
(algo (12))
(algo ("12"))
(algo ["12"])
(algo "12")
(defn bol [x] (if (x false) (false) (true)))
(bol false)
(defn bol [x] (if (x false) ("false") ("true")))
(bol false)
(defn bol [x] (if (x? false) ("false") ("true")))
(if "foo" "truue" "fals")
(defn bol [x] (if (x false) ("false") ("true")))
(bol false)
(defn bol [x] (if x false "false" "true"))
(defn bol [x] (if (x false) "false" "true"))
(bol false)
(bol "a")
(defn bol [x] (if x false "false" "true"))
(defn bol [x] (if x "true" "false"))
(bol false)
(defn bol [x] (if x "true" "false"))
(defn bol [x] ((if x [] "false" "true") (if x "true" "false") ))
(defn bol [x] ((if x? [] "false" "true") (if x "true" "false") ))
(if "foo" "kiquetal" "false")
(if "foo"?"kiquetal" "oe")
(if "foo"?"kiquetal" "oe" "asd")
(boolean [])
(defn bol [x] ((if x "true" "false")))
(bol false)
(defn bol [x] (if x "true" "false"))
(bol "as")
(bol false)
(bol true)
exit
(defn teen? [x] (if (>= x 13) if (<= 19 x) true false false))
(defn teen? [x] (if (>= x 13) true false))
(teen? 16)
(defn teen? [x] (if (>= x 13) (if <= 19 x ) true false))
(defn teen? [x] (if (>= x 13) (if <= 19 x ) true false false))
(defn teen? [x] (if (>= x 13) (if <= 19 x  true false false))
(defn teen? [x] (if (>= x 13) (if <= 19 x  true false false)))
(defn teen? [x] (if (>= x 13) if (<= 19 x)  true false false)))
(defn teen? [x] (if (>= x 13) (if (<= 19 x)  true false) false)))
(defn teen? [x] (if (>= x 13) (if (<= 19 x)  true false) false))
(teen? 19)
(teen? 20)
(teen? 23)
(defn teen? [x] (if (>= x 13) (if (<= x 19)  true false) false))
(teen? 23)
(teen? 19)
(teen? 18)
(defn teen? [x] (if (>= x 13) (if (<= x 19)  true false) false))
exit
(defn abs [x] (if (>= x 0) x (* x -1)))
(abs (5))
(abs 5)
(abs -5)
exit
(defn divides? [divisor n] (if (= 0 (mod n divisor) true false) )
(defn divides? [divisor n] (if (= 0 (mod n divisor) true false)))
(defn divides? [divisor n] (if (= 0 (mod n divisor)) true false))
(divides? 5 10)
(divides? 2 4)
(divides? 4 2)
exit
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "fizz" )
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "fizz")(= 0 (mod x 5) "buzz") (= 0 (mod x 15) "gotcha!") "") ))
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "fizz")(= 0 (mod x 5) "buzz") (= 0 (mod x 15) "gotcha!"
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "fizz")(= 0 (mod x 5) "buzz") (= 0 (mod x 15) "gotcha!") "") ))
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "fizz")(= 0 (mod x 5) "buzz") (= 0 (mod x 15) "gotcha!") "")))
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "fizz")(= 0 (mod x 5) "buzz") (= 0 (mod x 15) "gotcha!") ""))
(bizzbuzz 3)
(bizzbuzz 12)
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "as") "as"))
(bizzbuzz 3)
(bizzbuzz 13)
(mod 14 4)
(mod 10 5)
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "as") "as"))
(bizzbuzz 4)
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "as"))))
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "as")))
(defn bizzbuzz [x] (cond (= 0 (mod x 3))
(defn bizzbuzz [x] (cond (= 0 (mod x 3)))))
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "as") "asd")))
(defn bizzbuzz [x] (cond (= 0 (mod x 3) "as") "asd"))
(bizzbuzz 3)
(defn bizzbuzz [x] (if (= 0 (mod x 3)) "as" "asd"))
(bizzbuzz 3)
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "as" "asd"))
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "as" :else "asd"))
(bizzbuzz 3)
(bizzbuzz 12)
(bizzbuzz 13)
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "fizz" (= 0 (mod x 5)) "buzz" (= 0 (mod x 15)) "gotcha!" :else "asd"))
(bizzbuzz 13)
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "fizz" (= 0 (mod x 5)) "buzz" (= 0 (mod x 15)) "gotcha!" :else ""))
(bizzbuzz 13)
(bizzbuzz 48)
(bizzbuzz 70)
(bizzbuzz 45)
(defn bizzbuzz [x] (cond (= 0 (mod x 3)) "fizz" (= 0 (mod x 15)) "gotcha!" (= 0 (mod x 5)) "buzz" :else ""))
(bizzbuzz 45)
(defn bizzbuzz [x] (cond (= 0 (mod x 15)) "gotcha!" (= 0 (mod x 5)) "buzz" (= 0 (mod x 3)) "fizz" :else ""))
(bizzbuzz 45)
(bizzbuzz 2)
(bizzbuzz 70)
(bizzbuzz 48)
(defn bizzbuzz [x] (cond (= 0 (mod x 15)) "gotcha!" (= 0 (mod x 5)) "buzz" (= 0 (mod x 3)) "fizz" :else "")
\q
exit
(number? 4)
(defn generic-doublificate [x] (cond (number?x x ) :else "error"))
(defn generic-doublificate [x] (cond (number? x x ) :else "error"))
(defn generic-doublificate [x] (cond (number? x x ) else "error"))
(defn generic-doublificate [x] (cond (number? x) x  else "error"))
(defn generic-doublificate [x] (cond (number? x) x : else "error"))
(defn generic-doublificate [x] (cond (number? x) x :else "error"))
(generic-doublificate 3)
(defn generic-doublificate [x] (cond (number? x) x (empty? x) nill (or (list? x) (vector? x)) (count x) :else true))
(defn generic-doublificate [x] (cond (number? x) x (empty? x) nil (or (list? x) (vector? x)) (count x) :else true))
(generic-doublificate [1 2])
(defn generic-doublificate [x] (cond (number? x) x (empty? x) nil (or (list? x) (vector? x)) (* 2 (count x)) :else true))
(generic-doublificate [1 2])
(defn generic-doublificate [x] (cond (number? x) x (empty? x) nil (or (list? x) (vector? x)) (* 2 (count x)) :else true))
(generic-doublificate [])
(generic-doublificate {})
(generic-doublificate {:a 1})
(defn generic-doublificate [x] (cond (number? x) x (empty? x) nil (or (list? x) (vector? x)) (* 2 (count x)) :else true))
exit
(use 'i-am-in-the-land-of-booleans)
(use 'i-am-a-horse-in-the-land-of-booleans)
(use i-am-a-horse-in-the-land-of-booleans/teen?)
(use 'i-am-a-horse-in-the-land-of-booleans/teen?)
(teen? 12)
(defn not-teen? [x] (not (teen? 12) true false ))
(defn not-teen3? [x] (not (teen? 12) true false ))
(not-teen3? 25)
(user/not-teen3? 25)
exit
(defn not-teen3? [x] (not (teen? 24) true false))
(use 'i-am-horse-in-the-land-of-booleans)
(use 'i-am-a-horse-in-the-land-of-booleans)
(defn not-teen3? [x] (not (teen? 24) true false))
(not-teen3? 25)
exit
(use 'i-am-a-horse-in-the-land-of-booleans/teen?)
(refer 'i-am-a-horse-in-the-land-of-booleans/teen?)
(defn not-teen? [x] (> x 12) true false)
(not-teen? 12)
(defn not-teen? [x] (not (teen? 12) true false))
(defn teen? [x] (> (x 12) true false))
(defn not-teen? [x] (not (teen? 12) true false))
(not-teen? 23)
(teen? 12)
(defn teen? [x] (> x 12 true false))
(teen? 24)
(defn teen? [x] ( (> x 12) true false))
(teen? 12)
(defn teen? [x] ( (> x 12) true false))
exit
(defn not-teen? [x] (not (teen? 12)))
(defn not-teen? [x] (not (teen? 12))
l;
(defn not-teen? [x] (not (teen? 12))))
(use 'i-am-a-horse-in-the-land-of-booleans)
(defn not-teen? [x] (not (teen? 12))))
(defn not-teen? [x] (not (teen? 12)))
(defn not-teen3? [x] (not (teen? 12)))
(not-teen3 23)
(not-teen3? 23)
exit
(defn leap-year [x] (and (= 0 (mod x 4)) (!=0 (mod 4 100)) true))
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod 4 100))) true))
(leap-year 100)
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true))
(leap-year 100)
(leap-year 200)
(leap-year 400)
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400))) true))
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400)) true))
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400)) true false)))
(leap-year 400)
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400)) true )))
(leap-year 400)
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400)) true )))
(= 0 (mod 100 4))
(= 0 (mod 100 400))
(= 0 (mod 400 400))
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400)) true )))
(leap-year 400)
(defn leap-year [x] (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true (if (= 0 (mod x 400)) true "as" )))
(leap-year 400)
(defn leap-year [x] ((or ( if (= 0 (mod x 400)))   (and (= 0 (mod x 4)) (not (= 0 (mod x 100))))) true))
(defn leap-year [x] ((or ( if (= 0 (mod x 400)))   (and (= 0 (mod x 4)) (not (= 0 (mod x 100)))) true))
(defn leap-year [x] ((or ( if (= 0 (mod x 400)))   (and (= 0 (mod x 4)) (not (= 0 (mod x 100))) true))
(defn leap-year [x] (or (= 0 (mod x 400)) (and (= 0 (mod x 4)) (not (= 0 (mod x 100))))) true)
(defn leap-year [x] (or (= 0 (mod x 400)) (and (= 0 (mod x 4)) (not (= 0 (mod x 100)))) true ))
(leap-year 400)
(leap-year 15)
(mod 15 100)
(/ 15 100)
(mod 15 4)
(defn leap-year [x] (or (= 0 (mod x 400)) (and (= 0 (mod x 4)) (not (= 0 (mod x 100)))) true ))
(defn comparision [x] (and (= 0 (mod x 4)) (=0 (mod x 100))))
(defn comparision [x] (and (= 0 (mod x 4)) (= 0 (mod x 100))))
(comparision 12)
(comparision 15)
(defn comparision [x] (and (= 0 (mod x 4)) (= 0 (mod x 100))))
(comparision 400)
(defn comparision [x] (and (= 0 (mod x 4)) (not(= 0 (mod x 100)))))
(comparision 400)
(comparision 200)
(comparision 12)
(comparision 20)
(comparision 15)
(defn comparision [x] (or(and (= 0 (mod x 4)) (not(= 0 (mod x 100)))) (= 0 (mod x 400))))
(comparision 15)
(comparision 20)
(comparision 200)
(comparision 400)
(defn leap-year? [x] (or(and (= 0 (mod x 4)) (not(= 0 (mod x 100)))) (= 0 (mod x 400))))
(leap-year? 200)
(leap-year? 400)
exit
